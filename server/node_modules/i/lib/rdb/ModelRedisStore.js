!function () {
    var ModelRedisStore = function ModelRedisStore() {};

    ModelRedisStore.prototype.init = function init(db) {
        this.db = db;
    };

    ModelRedisStore.prototype.get = function get(pk, cb) {
        var deferred = Q.defer();
        cb = cb || function() {};
        var dbMulti = this.db.multi();
        dbMulti.hkeys(this.abb + pk);
        dbMulti.hvals(this.abb + pk);
        dbMulti.exec(function(err, results) {
            if (err) {
                var ex = new I.Exception(10103, err);
                cb(ex);
                deferred.reject(ex);
                return;
            }

            var keys = results[0];
            var data = results[1];

            // convert '1' to 1
            var array = [];
            var util = I.Util;
            for (var i = 0; i < data.length; ++i) {
                array[keys[i]] = util.isUInt(data[i]) ? parseInt(data[i]) : data[i];
            }

            var modelClass = this.getModel();
            var model = new modelClass(array);
            if (array.length !== 0) {
                model.fromStore = true;
            }
            cb(null, model);
            deferred.resolve(model);
        }.bind(this));
        return deferred.promise;
    };

    ModelRedisStore.prototype.add = function add(model, cb) {
        var deferred = Q.defer();
        cb = cb || function() {};
        if (model instanceof this.getModel() === false) {
            var ex = new I.Exception(10101);
            cb(ex);
            deferred.reject(ex);
            return deferred.promise;
        }
        if (this.pkAutoIncrement) {
            this.db.incr(I.Const.Frame.GLOBAL_KEY_PREFIX + this.abb, function(err, id) {
                if (err) {
                    var ex = new I.Exception(10104, err);
                    cb(ex);
                    deferred.reject(ex);
                    return;
                }
                this.addHash(model, function(err, model, result) {
                    if (err) {
                        cb(err);
                        deferred.reject(ex);
                        return;
                    }
                    cb(null, model, result);
                    deferred.resolve(model, result);
                }, id);
            }.bind(this));
        } else {
            this.addHash(model, function(err, model, result) {
                if (err) {
                    cb(err);
                    deferred.reject(ex);
                    return;
                }
                cb(null, model, result);
                deferred.resolve(model, result);
            });
        }
        return deferred.promise;
    };

    ModelRedisStore.prototype.addHash = function addHash(model, cb, id) {
        if (id === undefined) {
            var key = model.getPK();
        } else {
            model.setPK(id);
            var key = id;
        }
        var toDB = model.toAdd();
        if (I.Util.getLength(toDB) === 0) return cb(new I.Exception(10105));

        this.db.hmset(this.abb + key, toDB, function(err, result) {
            if (err) return cb(new I.Exception(10111, err));
            model.reset();
            cb(null, model, result);
        });
    };

    ModelRedisStore.prototype.del = function del(input, cb) {
        var deferred = Q.defer();
        cb = cb || function() {};
        var key;
        if (I.Util.isString(input)) {
            key = this.abb + input;
        } else if (input instanceof this.getModel()){
            key = this.abb + input.getPK();
        } else {
            var ex = new I.Exception(10126);
            cb(ex);
            deferred.reject(ex);
            return;
        }

        this.db.del(key, function(err, result) {
            if (err) {
                var ex = new I.Exception(10110, err);
                cb(ex);
                deferred.reject(ex);
            }
            cb(null, result);
            deferred.resolve(result);
        });
        return deferred.promise;
    };

    ModelRedisStore.prototype.update = function update(model, cb) {
        var deferred = Q.defer();
        cb = cb || function() {};
        if (model instanceof this.getModel() === false) {
            var ex = new I.Exception(10106, err);
            cb(ex);
            deferred.reject(ex);
            return;
        }
        var toDB = model.toUpdate(true);
        // nothing to update
        if (I.Util.getLength(toDB) === 0) {
            cb(null, model);
            deferred.resolve(model);
            return;
        }

        this.db.hmset(this.abb + model.getPK(), toDB, function(err, result) {
            if (err) {
                var ex = new I.Exception(10119, err);
                cb(ex);
                deferred.reject(ex);
                return;
            }
            model.reset();
            cb(null, model, result);
            deferred.resolve(model, result);
        });
        return deferred.promise;
    };

    ModelRedisStore.prototype.sync = function sync(model, cb) {
        cb = cb || function() {};
        if (model.tagAddSync) {
            this.addHash(model, cb, model.getPK());
        } else if (model.tagDelSync) {
            this.del(model, cb);
        } else {
            this.update(model, cb);
        }
    };

    I.Util.require('ModelRedisStore', 'Models', ModelRedisStore);
}();
